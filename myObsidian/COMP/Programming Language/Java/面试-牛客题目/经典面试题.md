## 为什么重写 equals 还要重写 hashcode？
#### What is equals and hashcode
```java
public native int hashCode();

public boolean equals(Object obj) {
        return (this == obj);
}
```
from the code above we can see `equals` just compare the memory address of two object. 
Lets us look at the annotation of `hashcode`
```java
 /**
     * Returns a hash code value for the object.  
     
     * This method is
     * supported for the benefit of hash tables such as those provided by
     * {@link java.util.HashMap}.
     * <p>
     * The general contract of {@code hashCode} is:
     * <ul>
     
     * <li>Whenever it is invoked on the same object more than once during
     *     an execution of a Java application, the {@code hashCode} method
     *     must consistently return the same integer, 
     *     provided no information
     *     used in {@code equals} comparisons on the object is modified.
     
        // 这里没看懂 但是测试了一下，如果同一个对象属性变化了，它的hash值也会不变
     
     
     *     This integer need not remain consistent from one execution of an
     *     application to another execution of the same application.
     * <li>If two objects are equal according to the {@code equals(Object)}
     *     method, then calling the {@code hashCode} method on each of
     *     the two objects must produce the same integer result.
     
     
     * <li>It is <em>not</em> required that if two objects are unequal
     *     according to the {@link java.lang.Object#equals(java.lang.Object)}
     *     method, then calling the {@code hashCode} method on each of the
     *     two objects must produce distinct integer results.  However, the
     *     programmer should be aware that producing distinct integer results
     *     for unequal objects may improve the performance of hash tables.
     * </ul>
     * <p>
     * As much as is reasonably practical, the hashCode method defined by
     * class {@code Object} does return distinct integers for distinct
     * objects. (This is typically implemented by converting the internal
     * address of the object into an integer, but this implementation
     * technique is not required by the
     * Java&trade; programming language.)
     *
     * @return  a hash code value for this object.
     * @see     java.lang.Object#equals(java.lang.Object)
     * @see     java.lang.System#identityHashCode
     */
```
According to Effective Java
> 每个覆盖了`equals`方法的类中，必须覆盖`hashCode`。如果不这么做，就违背了hashCode的通用约定

### Why they can co-exist?
From above,  we can see that we use `equals` and `hashcode` to see if two object are equal. 
-   equals - 保证比较对象是否是绝对相等的 (for relaiablty)
-   hashCode - 保证在最快的时间内判断两个对象是否相等，可能有误差值 (for performance)
- 同一个对象的hashCode一定相等，不同对象的hashCode也可能相等，这是因为hashCode是根据地址**hash出来的一个int 32 位的整型数字**，相等是在所难免。
-   equals比较的是两个对象的地址，**同一个对象地址肯定相同**，不同的对象地址一定不同，可靠性是这么来的。

For example: `put()` function in HashMap
```java
if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
```
1.  先比较 **hash** (通过hashCode的高16位和低16位进行异或运算得出的) ，因为两个相同的对象hash值一定相等。
2.  再比较两个对象的地址是否相同，**== 判断是否绝对相等，而equals判断是否客观相等**

### what if we jus override the equals
**两个相等的对象必须具有相等的散列码（Java关键约定）**
举一个例子：
如果一个只重写了**equals(比较所有属性是否相等)**的类 new 出了两个**属性相同的对象**。这时可以得到的信息是这个属性相同的对象地址肯定不同，但是equals是true，hashCode返回的是不相等的(一般不会出现hash碰撞)。

也就是说这个类对象违背了Java对于两个对象相等的约定。违背约定的原因是 **可靠的equals判断两个对象是相等的，但是他们两个的散列码确是不相等的。**


总结来说：
equals 为 true ， hashCode 必须相等
hashCode 相等时 ， equals 可以不用为 true （也就是hash碰撞的时候）

3. == 和 equals 比较的区别
4. 为啥有时会出现 4.0 - 3.6 = 0.40000001 这种现象？
5. final 关键字的作用
# 介绍 Java 的集合类

7. ArrayList 和 LinkedList 的区别