## 并发编程初探
### Java 天生多线程
在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。

当前的main函数就是一个 JVM 进程。 打印出来的 6 条线程信息就是进程中的多条线程。
```java
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;

public class ThreadPrint {

	public static void main(String[] args) throws InterruptedException {

// 获取Java线程管理MXBean

		ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();

// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息

		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);

// 遍历线程信息，仅打印线程ID和线程名称信息

		for (ThreadInfo threadInfo : threadInfos) {

			System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());

		}

		Thread.sleep(1000000); jps jstack

	}

}

```

[1] main 主线程
[2] Reference Handler 引用处理线程 
   ： [强，软，弱，虚](https://blog.csdn.net/jiangxiulilinux/article/details/105391516). gc 时候有不同的表现 ---jvm 深入分析
[3] Finalizer： JVM 垃圾回收相关内容
	1. 只有当开始一轮垃圾收集的时候，才会开始调用finalize方法
	2. daemon prio=10 高优先级的守护线程
	3. jvm在垃圾收集的时候，会将**失去引用**的对象封装到我们的 Fianlizer 对象（Reference）， 放入我们的 F-queue 队列中。由 Finalizer 线程执行Finalize方法
[4] Signal Dispatcher: 信号分发
	我们通过cmd 发送jstack，传到了jvm进程，这时候信号分发器就要发挥作用
[5] Attach Listener: 附加监听器
	简单来说，他是jdk里边一个工具类提供的**jvm** **进程之间通信**的工具。 
	java -version; jvm -- jstack、jmap、dump） 进程间的通信。
	开启我们这个线程的两个方式
	1. 通过jvm参数开启。-XX: StartAttachListener
	2. 延迟开启： cmd -- java -version --> JVM 适时开启A L 线程
[10] Common-Cleaner
```
"Monitor Ctrl-Break" #6 daemon prio=5 os_prio=0 tid=0x000000001a932800 nid=0x3bf8 runnable [0x000000001b96e000]

java.lang.Thread.State: RUNNABLE

at java.net.SocketInputStream.socketRead0(Native Method)

at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)

at java.net.SocketInputStream.read(SocketInputStream.java:170)

at java.net.SocketInputStream.read(SocketInputStream.java:141)

at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)

at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)

at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)

- locked <0x00000000d67070b8> (a java.io.InputStreamReader)

at java.io.InputStreamReader.read(InputStreamReader.java:184)

at java.io.BufferedReader.fill(BufferedReader.java:161)

at java.io.BufferedReader.readLine(BufferedReader.java:324)

- locked <0x00000000d67070b8> (a java.io.InputStreamReader)

at java.io.BufferedReader.readLine(BufferedReader.java:389)

at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:64)

  

"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x0000000019a39000 nid=0x283c waiting on condition [0x0000000000000000] prio=5 延迟开启的问题。

java.lang.Thread.State: RUNNABLE

  

"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x0000000019a38800 nid=0x1dd4 runnable [0x0000000000000000]

java.lang.Thread.State: RUNNABLE

  

"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x0000000017ae8800 nid=0x3708 in Object.wait() [0x0000000019e9f000] （Finalizer 专注垃圾收集，垃圾收集 -- 并行收集，不阻碍用户线程，低优先级线程。 prio=8 他是一个守护线程啊。而且这个线程目前并没有真正的开启，不足以发生minorgc或者是 full gc、）

java.lang.Thread.State: **WAITING (on object monitor)**

at java.lang.Object.wait(Native Method)

- waiting on <0x00000000d6108e98> (a java.lang.ref.ReferenceQueue$Lock)

at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)

- locked <0x00000000d6108e98> (a java.lang.ref.ReferenceQueue$Lock)

at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)

at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

  

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x0000000017ae1800 nid=0x1ee0 in Object.wait() [0x000000001999f000] （引用处理线程-GC相关线程：GC 很重要啊，优先级还挺高）

java.lang.Thread.State: WAITING (on object monitor)

at java.lang.Object.wait(Native Method)

- waiting on <0x00000000d6106b40> (a java.lang.ref.Reference$Lock)

at java.lang.Object.wait(Object.java:502)

at java.lang.ref.Reference.tryHandlePending(Reference.java:191)

- locked <0x00000000d6106b40> (a java.lang.ref.Reference$Lock)

at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

  

"main" #1 prio=5 os_prio=0 tid=0x00000000028f4800 nid=0x25ac waiting on condition [0x00000000028ef000] （操作系统面向的是JVM 进程，JVM 进程里面向的是 我们的main函数，。所以对于我们的操作系统如何看待我们的main函数优先级，无所谓。 只要os 给我们jvm进程足够公平的优先级就行。）

java.lang.Thread.State: TIMED_WAITING (sleeping)

at java.lang.Thread.sleep(Native Method)

at com.boot.jdk.ThreadPrint.main(ThreadPrint.java:20)
```


### 线程的优先级
在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配CPU时间片的数量要多于优先级低的线程。
**设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。

```java
public class ThreadPrority {

	public static void main(String[] args){

		System.out.println(Thread.currentThread().getName()+"("+Thread.currentThread().getPriority()+ ")");
		
		Thread t1=new MyThread("t1"); // 新建t1
		Thread t2=new MyThread("t2"); // 新建t2
		t1.setPriority(1); // 设置t1的优先级为1
		t2.setPriority(10); // 设置t2的优先级为10
		t1.start(); // 启动t1
		t2.start(); // 启动t2
	}

}

class MyThread extends Thread{

	public MyThread(String name) {
		super(name);
	}
	public void run(){
	
		for (int i=0; i<5; i++) {
			System.out.println(
			Thread.currentThread().getName()+"("+
			Thread.currentThread().getPriority()+ ")"+", loop "+i);
	}

// Thread.sleep(100000); 

	}

};
```
结果五花八门，setPriority 没有绝对的作用
setPriority 这个方法，他是 jvm 提供的一个方法，并且能够调用 本地方法setPriority0. 我们发现优先级貌似没有起作用，
为什么？ 
	1. 我们现在的计算机都是多核的，t1，t2 会让哪个cpu处理不好说。由不同的cpu同时提供资源执行。
	2. 优先级不代表先后顺序。哪怕你的优先级低，也是有可能先拿到我们的cpu时间片的，只不过这个时间片比高优先级的线程的时间片短。 **优先级针对的是 cpu时间片的长短问题**。 
	3. 目前工作中，实际项目里，**不必要**使用setPriority方法。我们现在都是用 hystrix， sential也好，一些开源的信号量控制工具，都能够实现线程资源的合理调度。这个 setPriority方法，很难控制。实际的运行环境太复杂。
```java
public final void setPriority(int newPriority) {
	ThreadGroup g; // main 线程
	checkAccess(); // 确保当前线程有权限访问。
	if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
		throw new IllegalArgumentException();
	} // 1 到 10 之间

	if((g = getThreadGroup()) != null) {
		if (newPriority > g.getMaxPdriority()) {
			newPriority = g.getMaxPriority();
		} //线程组中最大线程： 都是10 除非设置
	setPriority0(priority = newPriority);// 本地方法

	}
}

public final void checkAccess() {
	SecurityManager security = System.getSecurityManager();

	if (security != null) {
		security.checkAccess(this);
	}

}

```
 ### 守护线程
Daemon线程是一种支持型线程，因为它**主要被用作程序中后台调度以及支持性工作**。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调 用Thread.setDaemon(true)将线程设置为Daemon线程。
```java
public class ThreadDaemon {
	public static void main(String[] args) {
		Thread thread = new Thread(new DaemonThread(),"Daemon Thread!");
		thread.setDaemon(true); // 守护线程
		thread.start();
		// main 线程退出
	}

	static class DaemonThread implements Runnable {
		@Override
		public void run() {
			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			} finally { //finally 不能够保证我们的守护线程的最终执行
				System.out.println("FINISH!");
			}
		}
	}

}
```

```java
public final void setDaemon(boolean on) {
	checkAccess();

	if (isAlive()) {
		throw new IllegalThreadStateException();
		// 告诉我们，必须要先设置线程是否为守护线程，然后再调用start方法。如果你先调用start
	}
	daemon = on;
}
```

### 线程状态的转换
```java
public class ReadStackLog {
	public static void main(String[] args) throws JsonProcessingException {
	new Thread(new TimeWaiting (), "TimeWaitingThread").start();
	new Thread(new Waiting(), "WaitingThread").start();
	// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞
	new Thread(new Blocked(), "BlockedThread-1").start();
	new Thread(new Blocked(), "BlockedThread-2").start();
	}
}
// 该线程不断地进行睡眠
class TimeWaiting implements Runnable {
	@SneakyThrows
	@Override
	public void run() {
		while (true) {
			Thread.sleep(1000000);
		}
	}
}
// 该线程在Waiting.class实例上等待
class Waiting implements Runnable {
@Override
	public void run() {
		while (true) {
			synchronized (Waiting.class) {
				try {
					Waiting.class.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}

}
// 该线程在Blocked.class实例上加锁后，不会释放该锁
class Blocked implements Runnable {
@SneakyThrows
	public void run() {
		synchronized (Blocked.class) {
			while (true) {
				Thread.sleep(1000000);
			}
		}
	}
}
```

```
"BlockedThread-2" #15 prio=5 os_prio=0 tid=0x000000001b956000 nid=0x22d8 waiting for monitor entry [0x000000001d0be000](发现死锁，一直不会释放的话)

	java.lang.Thread.State: BLOCKED (on object monitor)
	at com.boot.jdk.Blocked.run(ReadStackLog.java:45)
		- waiting to lock <0x00000000d67bca20> (a java.lang.Class for com.boot.jdk.Blocked)
	at java.lang.Thread.run(Thread.java:745)

"BlockedThread-1" #14 prio=5 os_prio=0 tid=0x000000001b955000 nid=0x4c4c waiting on condition [0x000000001cfbf000]
	java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at com.boot.jdk.Blocked.run(ReadStackLog.java:45)
		- locked <0x00000000d67bca20> (a java.lang.Class for com.boot.jdk.Blocked)
	at java.lang.Thread.run(Thread.java:745)

// 一个block 一个 sleeping

"WaitingThread" #13 prio=5 os_prio=0 tid=0x000000001b954800 nid=0x39cc in Object.wait() [0x000000001cebf000]
	java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
		- waiting on <0x00000000d67ba680> (a java.lang.Class for com.boot.jdk.Waiting)
	at java.lang.Object.wait(Object.java:502)
	at com.boot.jdk.Waiting.run(ReadStackLog.java:31)
		- locked <0x00000000d67ba680> (a java.lang.Class for com.boot.jdk.Waiting)
	at java.lang.Thread.run(Thread.java:745)


"TimeWaitingThread" #12 prio=5 os_prio=0 tid=0x000000001b951800 nid=0x3820 waiting on condition [0x000000001cdbe000]
	java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at com.boot.jdk.TimeWaiting.run(ReadStackLog.java:20)
	at java.lang.Thread.run(Thread.java:745)


"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x000000001a72b000 nid=0x4ea8 waiting on condition [0x0000000000000000]
	java.lang.Thread.State: RUNNABLE


"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x000000001a6d2800 nid=0x3d94 runnable [0x0000000000000000]
	java.lang.Thread.State: RUNNABLE


"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x000000001a6b1800 nid=0x4254 in Object.wait() [0x000000001ab8f000] （只有进行垃圾收集的时候，才会被notify。 用到我们的 signal Dispatcher）
	java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
		- waiting on <0x00000000d6108e98> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
		- locked <0x00000000d6108e98> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x00000000187c1000 nid=0x48a8 in Object.wait() [0x000000001a68f000] （引用处理线程。）Thread.start 之后，他会进入一个就绪状态，还没有分配到 cpu的执行权。 当cpu的时间片切换到他的时候，他才会开始执行，进入running状态
	java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
		- waiting on <0x00000000d6106b40> (a java.lang.ref.Reference$Lock)
	at java.lang.Object.wait(Object.java:502)
	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
		- locked <0x00000000d6106b40> (a java.lang.ref.Reference$Lock)
	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)
	
```
<img src="https://raw.githubusercontent.com/PANhuihuihuihui/PicBed/main/20220625180955.png"/>
#### 代码分析
```java
public enum State {
NEW,
RUNNABLE,
BLOCKED,
// monitor lock only on synchronized have the block state
WAITING,
	// {@link Object#wait() Object.wait} with no timeout</li>
	// {@link #join() Thread.join} with no timeout</li>
	// {@link LockSupport#park() LockSupport.park}</li>
TIMED_WAITING,
	/**
	{@link #sleep Thread.sleep}
	{@link Object#wait(long) Object.wait} with timeout
	{@link #join(long) Thread.join} with timeout
	{@link LockSupport#parkNanos LockSupport.parkNanos}
	{@link LockSupport#parkUntil LockSupport.parkUntil}
	*/
TERMINATED;
// 六种 但是博客说的七种是在runable下面的划分：通过cpu执行权 running
}
// Thread.join 他底层代码调用的是 Object的 wait方法（后边会带大家看 join方法的jdk源码）。那么想要唤醒join方法，就需要使用 object的notify以及 notifyall

```
### 线程的初始化
#### init
一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的（sync）ID来标识这个child线程。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。
1. 尊重线程初始化穿入的threadgroup 次选System security mananger 的 tg；再次选 parent的 tg。
2. NEW状态的线程，会添加到threadGroup。
3. 新的线程的属性依赖于 父类线程。
```java
private Thread(ThreadGroup g, Runnable target, String name,
		long stackSize, AccessControlContext acc,
		boolean inheritThreadLocals) {
	if (name == null) {
		throw new NullPointerException("name cannot be null");
	}
	
	this.name = name;
	
	Thread parent = currentThread();
	
	SecurityManager security = System.getSecurityManager();
	if (g == null) {
		/* Determine if it's an applet or not */
		/* If there is a security manager, ask the security manager
		what to do. */
		if (security != null) {
			g = security.getThreadGroup();
		}
		/* If the security manager doesn't have a strong opinion
		on the matter, use the parent thread group. */
		if (g == null) {
			g = parent.getThreadGroup();
		}
	}
	
	
	/* checkAccess regardless of whether or not threadgroup is
	explicitly passed in. */
	g.checkAccess();
	
	/*
	* Do we have the required permissions?
	*/
	
	if (security != null) {
		if (isCCLOverridden(getClass())) {
			security.checkPermission(
			SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);
		}
	}
	// NEW状态的线程，会添加到threadGroup。
	g.addUnstarted();
	// 新的线程的属性依赖于 父类线程。
	this.group = g;
	this.daemon = parent.isDaemon();
	this.priority = parent.getPriority();
	if (security == null || isCCLOverridden(parent.getClass()))
		this.contextClassLoader = parent.getContextClassLoader();
	else
		this.contextClassLoader = parent.contextClassLoader;
	
	this.inheritedAccessControlContext =
	acc != null ? acc : AccessController.getContext();
	
	this.target = target;
	
	setPriority(priority);
	
	if (inheritThreadLocals && parent.inheritableThreadLocals != null)
		this.inheritableThreadLocals = 
		ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
	/* Stash the specified stack size in case the VM cares */
	this.stackSize = stackSize;
	
	/* Set thread ID */
	this.tid = nextThreadID();

}


private static synchronized long nextThreadID() {  
	return ++threadSeqNumber;  
}

//保证我们的tid的唯一性。
```
#### start
线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。
1. 避免多线程同时启动一个线程。IllegalThreadStateException
2. start0 完全执行完之前，线程处于 Ready
3. 完成后，只要cpu分配执行权，我们的线程就进入了Running状态。
4. _Start0_ _这个异常，会直接反馈给我们的调用线程。Main函数里边的_ thread.start方法。 **防止我们的thread.start方法感知不到异常**，导致程序的错误的继续执行。
```java
private volatile int threadStatus; // 二次确保不会同时进行
public synchronized void start() {
	/**
	* This method is not invoked for the main method thread or "system"
	* group threads created/set up by the VM. Any new functionality added
	* to this method in the future may have to also be added to the VM.
	* A zero status value corresponds to state "NEW".
	*/
	if (threadStatus != 0)
		throw new IllegalThreadStateException();
	/* Notify the group that this thread is about to be started
	* so that it can be added to the group's list of threads
	* and the group's unstarted count can be decremented. */
	group.add(this);
	boolean started = false;
	try {
		start0();
		started = true;
	} finally {
		try {
			if (!started) {
				group.threadStartFailed(this);
			}
		} catch (Throwable ignore) {
			/* do nothing. If start0 threw a Throwable then
			it will be passed up the call stack */
		}
	}

}
```
### sleep
1. 是否释放锁：否
2. 是否对中断敏感： 是
3. 是否释放CPU： 是
```java
/**
* Causes the currently executing thread to sleep (temporarily cease
* execution) for the specified number of milliseconds plus the specified
* number of nanoseconds, subject to the precision and accuracy of system
* timers and schedulers. The thread does not lose ownership of any
* monitors.
*/
public static native void sleep(long millis) throws InterruptedException
```
### Wait
1. 是否释放锁：是
2. 是否对中断敏感： 是
3. 是否释放CPU： 是
	让出 CPU 时间片。进入等待队列。（sync时候，深入介绍。waitset， _cxq, entrylist）


### Join
释放的是当前调用 join方法的那个对象的锁。普通方法
1. 是否释放锁：具体要看当前的锁对象是谁。如果是调用join方法的锁对象，则释放。
2. 是否对中断敏感： 是
3. 是否释放CPU： 是 底层调用的wait()
```java
public final synchronized void join(final long millis)
throws InterruptedException {
	if (millis > 0) {
		if (isAlive()) {
			final long startTime = System.nanoTime();
			long delay = millis;
		do {
			wait(delay);
		} while (isAlive() && (delay = millis -
			TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) > 0);
	}
	} else if (millis == 0) {
		while (isAlive()) {
		wait(0); 
		// 这个wait是调用的Object的，但是这是父类。其实这个wait方法前边有一个隐含的意义： this.wait(不是很准确)--》 当前的线程类（Thread类--有一个当前的线程）。 其实目前来看，这个是当前线程释放了cpu，而且是当前线程（Thread类）这个对象释放了锁。.
	}
	} else {
		throw new IllegalArgumentException("timeout value is negative");
	}

}
```

### 线程之间的通信方式
1. volitate 、synchronize、lock。（都保证可见性）
2. wait、notify、await() 、 signal
3. 管道输入、输出流  (示例代码：PipeInOut.java)
	  管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于**线程之间的数据传输，而传输的媒介为内存。**
	管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。
4. Thread.join() ： 隐式唤醒。等待其他线程执行完成，其他线程会发送唤醒信号。
5. ThradLocal() ---》支持子线程集成的一种形式。埋点。
6. 线程中断
```java
public class PipeInOut {
    public static void main(String[] args) throws IOException {
        PipedWriter out = new PipedWriter();
        PipedReader in = new PipedReader();
        // 将输出流和输入流进行连接，否则在使用时会抛出IOException
        out.connect(in);
        Thread printThread = new Thread(new Print(in), "PrintThread");
        printThread.start();
        int receive = 0;
        try {
            while ((receive = System.in.read()) != -1) {
                out.write(receive);
            }
        } finally {
            out.close();
        }
    }
    static class Print implements Runnable {
        private PipedReader in;
        public Print(PipedReader in) {
            this.in = in;
        }
        public void run() {
            int receive = 0;
            try {
                while ((receive = in.read()) != -1) {
                    System.out.print((char) receive);
                }
            } catch (IOException ex) {
            }
        }
    }
}
```
1. sleep is interrupted : false 因为先清除标志位，后抛出异常
```java
public class ThreadInterrupted {
    public static void main(String[] args) throws InterruptedException {
        // sleepThread不停的尝试睡眠
        Thread sleepThread = new Thread(new SleepRunner(), "SleepThread");
        sleepThread.setDaemon(true);
        Thread busyThread = new Thread(new BusyRunner(), "BusyThread");
        busyThread.setDaemon(true);
        sleepThread.start();
        busyThread.start();
        // 休眠5秒，让sleepThread和busyThread充分运行
        TimeUnit.SECONDS.sleep(5);
        sleepThread.interrupt();
        busyThread.interrupt();
        //sleep方法应中断，肯定会中断sleep。在抛出异常之前，会清理掉我们的 中断标志。 会返回false，因为当前线程已经停止了。
        System.out.println("SleepThread interrupted is " + sleepThread.isInterrupted());
  
       // busy thread ,没有立即响应中断，知识他的中断标志位 显示 被中断，这个是isInterrupted会返回true。
        System.out.println("BusyThread interrupted is " + busyThread.isInterrupted());
        // 防止sleepThread和busyThread立刻退出
        TimeUnit.SECONDS.sleep(5);
    }
  
    static class SleepRunner implements Runnable {
        @SneakyThrows
        @Override
        public void run() {
            while (true) {
                try {
                    // 先清除标志，后抛异常、（sleep）
                    TimeUnit.SECONDS.sleep(100);
                } catch (Exception e) {
                    System.out.println("======");
                }
            }
        }
    }
    static class BusyRunner implements Runnable {
        @Override
        public void run() {
            while (true) {
            }
        }
    }
}

```
### Ch2 synchronized 全解读
#### synchronized 的使用 javap -v 深入查看
1. 普通方法: 锁对象 我们的对象（new 出来的，谁调用这个方法，锁作用于谁身上）
2. 静态方法: 锁对象：我们的对象所属的class，全局只有一个。（类型，放到方法区的包括我们的真正的.class文件的二进制文件都最终加载到了运行时数据区的方法区）
3. 同步代码块： 
```java
public class SyncUsingWay {
    public synchronized void SyncMethod() {
        System.out.println("SyncMethod");
    }
    public synchronized static void StaticSyncMethod(){
        System.out.println("StaticSyncMethod");
    }
    public void method(){
        // 静态代码块
        synchronized (this) {
            System.out.println("method");
        }
    }
}
```
```text
Classfile /E:/IdeaWorkspace/demo/target/classes/com/boot/jdk/SyncUsingWay.class
  Last modified 2022-5-8; size 917 bytes
  MD5 checksum 9a53c6cd6851b0895ead00ce639fde81
  Compiled from "SyncUsingWay.java"
public class com.boot.jdk.SyncUsingWay
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool
   #1 = Methodref          #8.#30         // java/lang/Object."<init>":()V
   #2 = Fieldref           #31.#32        // java/lang/System.out:Ljava/io/PrintStream;
   #3 = String             #16            // SyncMethod
   #4 = Methodref          #33.#34        // java/io/PrintStream.println:(Ljava/lang/String;)V
   #5 = String             #17            // StaticSyncMethod
   #6 = String             #18            // method
   #7 = Class              #35            // com/boot/jdk/SyncUsingWay
   #8 = Class              #36            // java/lang/Object
   #9 = Utf8               <init>
  #10 = Utf8               ()V
  #11 = Utf8               Code
  #12 = Utf8               LineNumberTable
  #13 = Utf8               LocalVariableTable
  #14 = Utf8               this
  #15 = Utf8               Lcom/boot/jdk/SyncUsingWay;
  #16 = Utf8               SyncMethod
  #17 = Utf8               StaticSyncMethod
  #18 = Utf8               method
  #19 = Utf8               StackMapTable
  #20 = Class              #35            // com/boot/jdk/SyncUsingWay
  #21 = Class              #36            // java/lang/Object
  #22 = Class              #37            // java/lang/Throwable
  #23 = Utf8               main
  #24 = Utf8               ([Ljava/lang/String;)V
  #25 = Utf8               args
  #26 = Utf8               [Ljava/lang/String;
  #27 = Utf8               MethodParameters
  #28 = Utf8               SourceFile
  #29 = Utf8               SyncUsingWay.java
  #30 = NameAndType        #9:#10         // "<init>":()V
  #31 = Class              #38            // java/lang/System
  #32 = NameAndType        #39:#40        // out:Ljava/io/PrintStream;
  #33 = Class              #41            // java/io/PrintStream
  #34 = NameAndType        #42:#43        // println:(Ljava/lang/String;)V
  #35 = Utf8               com/boot/jdk/SyncUsingWay
  #36 = Utf8               java/lang/Object
  #37 = Utf8               java/lang/Throwable
  #38 = Utf8               java/lang/System
  #39 = Utf8               out
  #40 = Utf8               Ljava/io/PrintStream;
  #41 = Utf8               java/io/PrintStream
  #42 = Utf8               println
  #43 = Utf8               (Ljava/lang/String;)V
{
  public com.boot.jdk.SyncUsingWay();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."**<init>**":()V
         4: return
      LineNumberTable:
        line 3: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/boot/jdk/SyncUsingWay;
  public synchronized void SyncMethod();
    descriptor: ()V
    flags: ACC_PUBLIC, **ACC_SYNCHRONIZED**
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #3                  // String SyncMethod
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 5: 0
        line 6: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  this   Lcom/boot/jdk/SyncUsingWay;
  public static synchronized void StaticSyncMethod();
    descriptor: ()V
    flags: ACC_PUBLIC, **ACC_STATIC, ACC_SYNCHRONIZED**
    Code:
      stack=2, locals=0, args_size=0
         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: ldc           #5                  // String StaticSyncMethod
         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
         8: return
      LineNumberTable:
        line 9: 0
        line 10: 8
  public void method();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         **3: monitorenter //** **进入同步代码块（进入临界范围内，锁的原子内部）**
         4: getstatic     #2                 // Field java/lang/System.out:Ljava/io/PrintStream;
         7: ldc           #6                  // String method
         9: invokevitual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        12: aload_1
        **13: monitorexit //** **正常退出同步代码块**
        14: goto          22
        17: astore_2
        18: aload_1
        **19: monitorexit //****防止任何异常情况下，退出同步代码块。JVM** **仍然可以释放锁**
        20: aload_2
        21: athrow
        22: return
      **Exception table: //****配合异常退出 monitorexit**
         from    to  target type
             4    14    17   any
            17    20    17   any
      LineNumberTable:
        line 13: 0
        line 14: 4
        line 15: 12
        line 16: 22
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  this   Lcom/boot/jdk/SyncUsingWay;
      StackMapTable: number_of_entries = 2
        frame_type = 255 /* full_frame */
          offset_delta = 17
          locals = [ class com/boot/jdk/SyncUsingWay, class java/lang/Object ]
          stack = [ class java/lang/Throwable ]
        frame_type = 250 /* chop */
          offset_delta = 4
SourceFile: "SyncUsingWay.java"
```



#### synchronized 的特性
1. 有序性 （读读 读写、写读、写写 互斥）
2. 可见性，排他性 （可见性是指多个线程访问⼀个资源时，该资源的状态、值信息等对于其他线程都是可见的。 synchronized和volatile都具有可见性，其中synchronized对⼀个类或对象加锁时，⼀个线程如果要访问该类或对象必须先获得它的锁，⽽这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到共享内存当中，保证资源变量的可见性。）
3. 原子性 (本质上是线程互斥保证的原子性)
4. 可重入性 （代码示例 ThreadReIn.java）
![Markword](https://raw.githubusercontent.com/PANhuihuihuihui/PicBed/main/20220630174521.png)

#### synchronized 的锁升级 -- 偏向锁
偏向锁使用的前提：
1. 至少JDK1.6 版本且开启了偏向锁配置。
  偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。
2. 被加锁的对象，没有真正、或者隐式的调用父类 Object 里边的hashcode方法。
	如果一旦调用了object的hashcode方法，那么我们的对象头里边就有真正的hashcode值了，如果偏向锁来进行markword的替换，至少要提供一个保存hashcode的地方吧？可惜的是，偏向锁并没有地方进行markword的保存，只有轻量级锁才会有“displace mark word
代码示例： SyncLockFlag.java
```java
public class SyncLockFlag {
    // 当我们开启了偏向锁，并且没有延迟开启的时候，新创建的对象的mark word 默认就是偏向锁状态的markword。
    // 只不过这个时候，因为没有现成争抢，除了我们的锁标志为和是否为偏向锁标志位，其他的位数都是0
    static MyObject myobject = new MyObject();
    public static void main(String[] args) throws InterruptedException {
        System.out.println("=====================未偏向线程的偏向锁============================");
        System.out.println(ClassLayout.parseInstance(myobject).toPrintable());
        HashMap map = new HashMap();
        map.put(myobject,""); //隐式的调用了hashcode方法: 会升级的轻量级锁，
        synchronized (myobject) {
            System.out.println("=====================偏向锁============================");
            System.out.println(ClassLayout.parseInstance(myobject).toPrintable());
        }
    }
    static class MyObject{
    }
}
```

为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在
**对象头: 存储线程ID**
**栈帧的锁记录里: 线程有自己的stack frame, lock record 储存当前线程的id**
存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向
**当前线程的偏向锁: id 的匹配** 。
如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的**偏向锁指向当前线程: 其实是cas 竞争替换线程id**

#### 偏向锁的撤销
面试时只需要回答： 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

```java
public class SyncSyncLockRelease {

    static Thread A;

    static Thread B;

    public static void main(String[] args) {

        final List<Object> list = new ArrayList<>();

        A = new Thread() {

            @SneakyThrows

            @Override

            public void run() {

                Object a = new Object();

                list.add(a);

                System.out.println("AAAA加锁前" + ClassLayout.parseInstance(a).toPrintable());

                synchronized (a) {

                    System.out.println("AAAA加锁中" + ClassLayout.parseInstance(a).toPrintable());

                }

                System.out.println("AAAA加锁后" + ClassLayout.parseInstance(a).toPrintable());

                //防止竞争 执行完后唤醒线程B/ 确保A线程 死亡 Terminated

                LockSupport.unpark(B);

            }

        };

        B = new Thread() {

            @Override

            public void run() {

                LockSupport.park();

                Object a = list.get(0);

                System.out.println("线程BBBB加锁前" + ClassLayout.parseInstance(a).toPrintable());

                synchronized (a) {

                    System.out.println("线程BBBB加锁中" + ClassLayout.parseInstance(a).toPrintable());

                }

                System.out.println("线程BBBB加锁后" + ClassLayout.parseInstance(a).toPrintable());

                System.out.println("新产生的对象" + ClassLayout.parseInstance(new Object()).toPrintable());

            }

        };

        A.start();

        B.start();

    }

}
```