## 并发编程初探
### Java 天生多线程
在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。

当前的main函数就是一个 JVM 进程。 打印出来的 6 条线程信息就是进程中的多条线程。
```java
import java.lang.management.ManagementFactory;
import java.lang.management.ThreadInfo;
import java.lang.management.ThreadMXBean;

public class ThreadPrint {

	public static void main(String[] args) throws InterruptedException {

// 获取Java线程管理MXBean

		ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();

// 不需要获取同步的monitor和synchronizer信息，仅获取线程和线程堆栈信息

		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);

// 遍历线程信息，仅打印线程ID和线程名称信息

		for (ThreadInfo threadInfo : threadInfos) {

			System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());

		}

		Thread.sleep(1000000); jps jstack

	}

}

```

[1] main 主线程
[2] Reference Handler 引用处理线程 
   ： [强，软，弱，虚](https://blog.csdn.net/jiangxiulilinux/article/details/105391516). gc 时候有不同的表现 ---jvm 深入分析
[3] Finalizer： JVM 垃圾回收相关内容
	1. 只有当开始一轮垃圾收集的时候，才会开始调用finalize方法
	2. daemon prio=10 高优先级的守护线程
	3. jvm在垃圾收集的时候，会将**失去引用**的对象封装到我们的 Fianlizer 对象（Reference）， 放入我们的 F-queue 队列中。由 Finalizer 线程执行Finalize方法
[4] Signal Dispatcher: 信号分发
	我们通过cmd 发送jstack，传到了jvm进程，这时候信号分发器就要发挥作用
[5] Attach Listener: 附加监听器
	简单来说，他是jdk里边一个工具类提供的**jvm** **进程之间通信**的工具。 
	java -version; jvm -- jstack、jmap、dump） 进程间的通信。
	开启我们这个线程的两个方式
	1. 通过jvm参数开启。-XX: StartAttachListener
	2. 延迟开启： cmd -- java -version --> JVM 适时开启A L 线程
[10] Common-Cleaner
```
"Monitor Ctrl-Break" #6 daemon prio=5 os_prio=0 tid=0x000000001a932800 nid=0x3bf8 runnable [0x000000001b96e000]

java.lang.Thread.State: RUNNABLE

at java.net.SocketInputStream.socketRead0(Native Method)

at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)

at java.net.SocketInputStream.read(SocketInputStream.java:170)

at java.net.SocketInputStream.read(SocketInputStream.java:141)

at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)

at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)

at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)

- locked <0x00000000d67070b8> (a java.io.InputStreamReader)

at java.io.InputStreamReader.read(InputStreamReader.java:184)

at java.io.BufferedReader.fill(BufferedReader.java:161)

at java.io.BufferedReader.readLine(BufferedReader.java:324)

- locked <0x00000000d67070b8> (a java.io.InputStreamReader)

at java.io.BufferedReader.readLine(BufferedReader.java:389)

at com.intellij.rt.execution.application.AppMainV2$1.run(AppMainV2.java:64)

  

"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x0000000019a39000 nid=0x283c waiting on condition [0x0000000000000000] prio=5 延迟开启的问题。

java.lang.Thread.State: RUNNABLE

  

"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x0000000019a38800 nid=0x1dd4 runnable [0x0000000000000000]

java.lang.Thread.State: RUNNABLE

  

"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x0000000017ae8800 nid=0x3708 in Object.wait() [0x0000000019e9f000] （Finalizer 专注垃圾收集，垃圾收集 -- 并行收集，不阻碍用户线程，低优先级线程。 prio=8 他是一个守护线程啊。而且这个线程目前并没有真正的开启，不足以发生minorgc或者是 full gc、）

java.lang.Thread.State: **WAITING (on object monitor)**

at java.lang.Object.wait(Native Method)

- waiting on <0x00000000d6108e98> (a java.lang.ref.ReferenceQueue$Lock)

at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)

- locked <0x00000000d6108e98> (a java.lang.ref.ReferenceQueue$Lock)

at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)

at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

  

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x0000000017ae1800 nid=0x1ee0 in Object.wait() [0x000000001999f000] （引用处理线程-GC相关线程：GC 很重要啊，优先级还挺高）

java.lang.Thread.State: WAITING (on object monitor)

at java.lang.Object.wait(Native Method)

- waiting on <0x00000000d6106b40> (a java.lang.ref.Reference$Lock)

at java.lang.Object.wait(Object.java:502)

at java.lang.ref.Reference.tryHandlePending(Reference.java:191)

- locked <0x00000000d6106b40> (a java.lang.ref.Reference$Lock)

at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)

  

"main" #1 prio=5 os_prio=0 tid=0x00000000028f4800 nid=0x25ac waiting on condition [0x00000000028ef000] （操作系统面向的是JVM 进程，JVM 进程里面向的是 我们的main函数，。所以对于我们的操作系统如何看待我们的main函数优先级，无所谓。 只要os 给我们jvm进程足够公平的优先级就行。）

java.lang.Thread.State: TIMED_WAITING (sleeping)

at java.lang.Thread.sleep(Native Method)

at com.boot.jdk.ThreadPrint.main(ThreadPrint.java:20)
```


### 线程的优先级
在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配CPU时间片的数量要多于优先级低的线程。
**设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。

```java
public class ThreadPrority {

	public static void main(String[] args){

		System.out.println(Thread.currentThread().getName()+"("+Thread.currentThread().getPriority()+ ")");
		
		Thread t1=new MyThread("t1"); // 新建t1
		Thread t2=new MyThread("t2"); // 新建t2
		t1.setPriority(1); // 设置t1的优先级为1
		t2.setPriority(10); // 设置t2的优先级为10
		t1.start(); // 启动t1
		t2.start(); // 启动t2
	}

}

class MyThread extends Thread{

	public MyThread(String name) {
		super(name);
	}
	public void run(){
	
		for (int i=0; i<5; i++) {
			System.out.println(
			Thread.currentThread().getName()+"("+
			Thread.currentThread().getPriority()+ ")"+", loop "+i);
	}

// Thread.sleep(100000); 

	}

};
```
结果五花八门，setPriority 没有绝对的作用
setPriority 这个方法，他是 jvm 提供的一个方法，并且能够调用 本地方法setPriority0. 我们发现优先级貌似没有起作用，
为什么？ 
	1. 我们现在的计算机都是多核的，t1，t2 会让哪个cpu处理不好说。由不同的cpu同时提供资源执行。
	2. 优先级不代表先后顺序。哪怕你的优先级低，也是有可能先拿到我们的cpu时间片的，只不过这个时间片比高优先级的线程的时间片短。 **优先级针对的是 cpu时间片的长短问题**。 
	3. 目前工作中，实际项目里，**不必要**使用setPriority方法。我们现在都是用 hystrix， sential也好，一些开源的信号量控制工具，都能够实现线程资源的合理调度。这个 setPriority方法，很难控制。实际的运行环境太复杂。
```java
public final void setPriority(int newPriority) {
	ThreadGroup g; // main 线程
	checkAccess(); // 确保当前线程有权限访问。
	if (newPriority > MAX_PRIORITY || newPriority < MIN_PRIORITY) {
		throw new IllegalArgumentException();
	} // 1 到 10 之间

	if((g = getThreadGroup()) != null) {
		if (newPriority > g.getMaxPdriority()) {
			newPriority = g.getMaxPriority();
		} //线程组中最大线程： 都是10 除非设置
	setPriority0(priority = newPriority);// 本地方法

	}
}

public final void checkAccess() {
	SecurityManager security = System.getSecurityManager();

	if (security != null) {
		security.checkAccess(this);
	}

}

```
### 守护线程
Daemon线程是一种支持型线程，因为它**主要被用作程序中后台调度以及支持性工作**。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调 用Thread.setDaemon(true)将线程设置为Daemon线程。
```java
public class ThreadDaemon {
	public static void main(String[] args) {
		Thread thread = new Thread(new DaemonThread(),"Daemon Thread!");
		thread.setDaemon(true); // 守护线程
		thread.start();
		// main 线程退出
	}

	static class DaemonThread implements Runnable {
		@Override
		public void run() {
			try {
				Thread.sleep(5000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			} finally { //finally 不能够保证我们的守护线程的最终执行
				System.out.println("FINISH!");
			}
		}
	}

}
```

```java
public final void setDaemon(boolean on) {
	checkAccess();

	if (isAlive()) {
		throw new IllegalThreadStateException();
		// 告诉我们，必须要先设置线程是否为守护线程，然后再调用start方法。如果你先调用start
	}
	daemon = on;
}
```

### 线程状态的转换
```java
public class ReadStackLog {
	public static void main(String[] args) throws JsonProcessingException {
	new Thread(new TimeWaiting (), "TimeWaitingThread").start();
	new Thread(new Waiting(), "WaitingThread").start();
	// 使用两个Blocked线程，一个获取锁成功，另一个被阻塞
	new Thread(new Blocked(), "BlockedThread-1").start();
	new Thread(new Blocked(), "BlockedThread-2").start();
	}
}
// 该线程不断地进行睡眠
class TimeWaiting implements Runnable {
	@SneakyThrows
	@Override
	public void run() {
		while (true) {
			Thread.sleep(1000000);
		}
	}
}
// 该线程在Waiting.class实例上等待
class Waiting implements Runnable {
@Override
	public void run() {
		while (true) {
			synchronized (Waiting.class) {
				try {
					Waiting.class.wait();
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}

}
// 该线程在Blocked.class实例上加锁后，不会释放该锁
class Blocked implements Runnable {
@SneakyThrows
	public void run() {
		synchronized (Blocked.class) {
			while (true) {
				Thread.sleep(1000000);
			}
		}
	}
}
```

```
"BlockedThread-2" #15 prio=5 os_prio=0 tid=0x000000001b956000 nid=0x22d8 waiting for monitor entry [0x000000001d0be000](发现死锁，一直不会释放的话)

	java.lang.Thread.State: BLOCKED (on object monitor)
	at com.boot.jdk.Blocked.run(ReadStackLog.java:45)
		- waiting to lock <0x00000000d67bca20> (a java.lang.Class for com.boot.jdk.Blocked)
	at java.lang.Thread.run(Thread.java:745)

"BlockedThread-1" #14 prio=5 os_prio=0 tid=0x000000001b955000 nid=0x4c4c waiting on condition [0x000000001cfbf000]
	java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at com.boot.jdk.Blocked.run(ReadStackLog.java:45)
		- locked <0x00000000d67bca20> (a java.lang.Class for com.boot.jdk.Blocked)
	at java.lang.Thread.run(Thread.java:745)

// 一个block 一个 sleeping

"WaitingThread" #13 prio=5 os_prio=0 tid=0x000000001b954800 nid=0x39cc in Object.wait() [0x000000001cebf000]
	java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
		- waiting on <0x00000000d67ba680> (a java.lang.Class for com.boot.jdk.Waiting)
	at java.lang.Object.wait(Object.java:502)
	at com.boot.jdk.Waiting.run(ReadStackLog.java:31)
		- locked <0x00000000d67ba680> (a java.lang.Class for com.boot.jdk.Waiting)
	at java.lang.Thread.run(Thread.java:745)


"TimeWaitingThread" #12 prio=5 os_prio=0 tid=0x000000001b951800 nid=0x3820 waiting on condition [0x000000001cdbe000]
	java.lang.Thread.State: TIMED_WAITING (sleeping)
	at java.lang.Thread.sleep(Native Method)
	at com.boot.jdk.TimeWaiting.run(ReadStackLog.java:20)
	at java.lang.Thread.run(Thread.java:745)


"Attach Listener" #5 daemon prio=5 os_prio=2 tid=0x000000001a72b000 nid=0x4ea8 waiting on condition [0x0000000000000000]
	java.lang.Thread.State: RUNNABLE


"Signal Dispatcher" #4 daemon prio=9 os_prio=2 tid=0x000000001a6d2800 nid=0x3d94 runnable [0x0000000000000000]
	java.lang.Thread.State: RUNNABLE


"Finalizer" #3 daemon prio=8 os_prio=1 tid=0x000000001a6b1800 nid=0x4254 in Object.wait() [0x000000001ab8f000] （只有进行垃圾收集的时候，才会被notify。 用到我们的 signal Dispatcher）
	java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
		- waiting on <0x00000000d6108e98> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:143)
		- locked <0x00000000d6108e98> (a java.lang.ref.ReferenceQueue$Lock)
	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:164)
	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:209)

"Reference Handler" #2 daemon prio=10 os_prio=2 tid=0x00000000187c1000 nid=0x48a8 in Object.wait() [0x000000001a68f000] （引用处理线程。）Thread.start 之后，他会进入一个就绪状态，还没有分配到 cpu的执行权。 当cpu的时间片切换到他的时候，他才会开始执行，进入running状态
	java.lang.Thread.State: WAITING (on object monitor)
	at java.lang.Object.wait(Native Method)
		- waiting on <0x00000000d6106b40> (a java.lang.ref.Reference$Lock)
	at java.lang.Object.wait(Object.java:502)
	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)
		- locked <0x00000000d6106b40> (a java.lang.ref.Reference$Lock)
	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:153)
	
```
<img src="https://raw.githubusercontent.com/PANhuihuihuihui/PicBed/main/20220625180955.png"/>
#### 代码分析
```java
public enum State {
NEW,
RUNNABLE,
BLOCKED,
// monitor lock only on synchronized have the block state
WAITING,
	// {@link Object#wait() Object.wait} with no timeout</li>
	// {@link #join() Thread.join} with no timeout</li>
	// {@link LockSupport#park() LockSupport.park}</li>
TIMED_WAITING,
	/**
	{@link #sleep Thread.sleep}
	{@link Object#wait(long) Object.wait} with timeout
	{@link #join(long) Thread.join} with timeout
	{@link LockSupport#parkNanos LockSupport.parkNanos}
	{@link LockSupport#parkUntil LockSupport.parkUntil}
	*/
TERMINATED;
// 六种 但是博客说的七种是在runable下面的划分：通过cpu执行权 running
}
// Thread.join 他底层代码调用的是 Object的 wait方法（后边会带大家看 join方法的jdk源码）。那么想要唤醒join方法，就需要使用 object的notify以及 notifyall

```
### 线程的初始化
#### init
一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的（sync）ID来标识这个child线程。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。
1. 尊重线程初始化穿入的threadgroup 次选System security mananger 的 tg；再次选 parent的 tg。
2. NEW状态的线程，会添加到threadGroup。
3. 新的线程的属性依赖于 父类线程。
```java
private Thread(ThreadGroup g, Runnable target, String name,
		long stackSize, AccessControlContext acc,
		boolean inheritThreadLocals) {
	if (name == null) {
		throw new NullPointerException("name cannot be null");
	}
	
	this.name = name;
	
	Thread parent = currentThread();
	
	SecurityManager security = System.getSecurityManager();
	if (g == null) {
		/* Determine if it's an applet or not */
		/* If there is a security manager, ask the security manager
		what to do. */
		if (security != null) {
			g = security.getThreadGroup();
		}
		/* If the security manager doesn't have a strong opinion
		on the matter, use the parent thread group. */
		if (g == null) {
			g = parent.getThreadGroup();
		}
	}
	
	
	/* checkAccess regardless of whether or not threadgroup is
	explicitly passed in. */
	g.checkAccess();
	
	/*
	* Do we have the required permissions?
	*/
	
	if (security != null) {
		if (isCCLOverridden(getClass())) {
			security.checkPermission(
			SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);
		}
	}
	// NEW状态的线程，会添加到threadGroup。
	g.addUnstarted();
	// 新的线程的属性依赖于 父类线程。
	this.group = g;
	this.daemon = parent.isDaemon();
	this.priority = parent.getPriority();
	if (security == null || isCCLOverridden(parent.getClass()))
		this.contextClassLoader = parent.getContextClassLoader();
	else
		this.contextClassLoader = parent.contextClassLoader;
	
	this.inheritedAccessControlContext =
	acc != null ? acc : AccessController.getContext();
	
	this.target = target;
	
	setPriority(priority);
	
	if (inheritThreadLocals && parent.inheritableThreadLocals != null)
		this.inheritableThreadLocals = 
		ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
	/* Stash the specified stack size in case the VM cares */
	this.stackSize = stackSize;
	
	/* Set thread ID */
	this.tid = nextThreadID();

}


private static synchronized long nextThreadID() {  
	return ++threadSeqNumber;  
}

//保证我们的tid的唯一性。
```
#### start
线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。
1. 避免多线程同时启动一个线程。IllegalThreadStateException
2. start0 完全执行完之前，线程处于 Ready
3. 完成后，只要cpu分配执行权，我们的线程就进入了Running状态。
4. _Start0_ _这个异常，会直接反馈给我们的调用线程。Main函数里边的_ thread.start方法。 **防止我们的thread.start方法感知不到异常**，导致程序的错误的继续执行。
```java
private volatile int threadStatus; // 二次确保不会同时进行
public synchronized void start() {
	/**
	* This method is not invoked for the main method thread or "system"
	* group threads created/set up by the VM. Any new functionality added
	* to this method in the future may have to also be added to the VM.
	* A zero status value corresponds to state "NEW".
	*/
	if (threadStatus != 0)
		throw new IllegalThreadStateException();
	/* Notify the group that this thread is about to be started
	* so that it can be added to the group's list of threads
	* and the group's unstarted count can be decremented. */
	group.add(this);
	boolean started = false;
	try {
		start0();
		started = true;
	} finally {
		try {
			if (!started) {
				group.threadStartFailed(this);
			}
		} catch (Throwable ignore) {
			/* do nothing. If start0 threw a Throwable then
			it will be passed up the call stack */
		}
	}

}
```
### sleep
1. 是否释放锁：否
2. 是否对中断敏感： 是
3. 是否释放CPU： 是
```java
/**
* Causes the currently executing thread to sleep (temporarily cease
* execution) for the specified number of milliseconds plus the specified
* number of nanoseconds, subject to the precision and accuracy of system
* timers and schedulers. The thread does not lose ownership of any
* monitors.
*/
public static native void sleep(long millis) throws InterruptedException
```
### Wait
1. 是否释放锁：是
2. 是否对中断敏感： 是
3. 是否释放CPU： 是
	让出 CPU 时间片。进入等待队列。（sync时候，深入介绍。waitset， _cxq, entrylist）


### Join
1. 是否释放锁：是
2. 是否对中断敏感： 是
3. 是否释放CPU： 是
```java
public final synchronized void join(final long millis)
throws InterruptedException {
if (millis > 0) {
if (isAlive()) {
final long startTime = System.nanoTime();
long delay = millis;
do {
wait(delay);
} while (isAlive() && (delay = millis -
TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) > 0);
}
} else if (millis == 0) {
while (isAlive()) {
wait(0);
}
} else {
	throw new IllegalArgumentException("timeout value is negative");
}

}
```